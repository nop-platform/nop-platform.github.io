<!DOCTYPE html>
<html lang="zh-CN" dir="ltr">
  <head>
    <meta charset="UTF-8">









  
  
  
    
  


  


  


  






  





  <title>为什么说XLang是一门创新的程序语言？ - Nop</title>


  <meta property="og:title" content="为什么说XLang是一门创新的程序语言？">


  <meta name="description" content="Nop Platform 2.0 是基于可逆计算原理从零开始构建的新一代低代码平台，它致力于克服低代码平台无法摆脱穷举法的困境，从理论层面超越组件技术，有效的解决粗粒度软件复用的问题。">
  <meta property="og:description" content="Nop Platform 2.0 是基于可逆计算原理从零开始构建的新一代低代码平台，它致力于克服低代码平台无法摆脱穷举法的困境，从理论层面超越组件技术，有效的解决粗粒度软件复用的问题。">



  
    
  


  <meta name="keywords" content="Nop,Nop平台,Nop 平台,Nop Platform,Nop社区,Nop 社区,Nop Community,可逆计算,软件构造理论,低代码,lowcode,low-code,low code,低代码平台,lcdp,软件工程">


<!-- 页面渲染兼容性 -->
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="renderer" content="webkit">
<meta name="viewport" content="width=device-width,initial-scale=1.0">

<!-- 订阅 -->

<meta name="theme-color" content="#0871ab">
<link rel="shortcut icon" href="/images/nop/logo.png">


    
<link rel="stylesheet" href="/stylesheets/global.css">

    
<link rel="stylesheet" href="/stylesheets/ksio/vendors/share.css">

<link rel="stylesheet" href="/local/syntax-highlighting.css">

<link rel="stylesheet" href="/stylesheets/pages/post.css">

<link rel="stylesheet" href="/stylesheets/pages/doc.css">

    
    
<script src="/javascripts/ksio/vendors/jquery-1.11.3.min.js"></script>

    
<script src="/javascripts/ksio/vendors/bootstrap.min.js"></script>

  </head>
  
  
  <body class="Page" itemscope itemtype="http://schema.org/WebPage">
    

  <header class="Page-header">
  <div class="navbar navbar-static-top">
    <div class="container-fluid">
      <div class="navbar-header">
        
          <button class="navbar-toggle collapsed" type="button" data-target=".Page-navs" data-toggle="collapse">
            <span class="sr-only">Toggle navs</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
        
        
          


  <a class="navbar-brand" href="/">Nop</a>


        
      </div>
      <!-- Nav menus -->
      <nav class="Page-navs navbar-collapse collapse">
        <ul class="nav navbar-nav navbar-right">
          
  
    <li class="dropdown">
      <a class="dropdown-toggle" href="javascript:void(0);" data-toggle="dropdown">学习 <span class="caret"></span></a>
      <ul class="dropdown-menu">
  
    <li><a href="/projects/nop-entropy/docs">指南</a>
</li>
  

  
    <li><a href="https://www.zhihu.com/column/reversible-computation?utm_source=https://nop-platform.gitee.io&amp;utm_medium=common-header" target="_blank" rel="external nofollow">文章</a>
</li>
  

  
    <li><a href="https://space.bilibili.com/3493261219990250?utm_source=https://nop-platform.gitee.io&amp;utm_medium=common-header" target="_blank" rel="external nofollow">视频</a>
</li>
  

</ul>
    </li>
  

  
    <li class="dropdown">
      <a class="dropdown-toggle" href="javascript:void(0);" data-toggle="dropdown">项目 <span class="caret"></span></a>
      <ul class="dropdown-menu">
  
    <li><a href="/projects/nop-entropy">Nop Entropy</a>
</li>
  

  
    <li><a href="/projects/nop-chaos">Nop Chaos</a>
</li>
  

</ul>
    </li>
  

  
    <li class="dropdown">
      <a class="dropdown-toggle" href="javascript:void(0);" data-toggle="dropdown">关于 <span class="caret"></span></a>
      <ul class="dropdown-menu">
  
    <li><a href="/community">社区</a>
</li>
  

  
    <li><a href="/team">团队</a>
</li>
  

</ul>
    </li>
  


        </ul>
      </nav>
    </div>
  </div>
</header>

<div class="Page-content">
  
  
    <aside class="Page-aside">
      <div class="AsideBrand">


  <a href="/">Nop</a>

</div>
      <nav class="AsideNav"><ul>
  
  
    
  
  
    <li>
      
      
      
      
      
        
        
        
        
          
          
        
        <a href="/projects/nop-entropy/docs/why-nop/">介绍</a>
      
      
        <ul>
  
  
    
  
  
    <li>
      
      
      
      
      
        
        
        
        
          
        
        <a href="/projects/nop-entropy/docs/">文档概览</a>
      
      
    </li>
  
    <li>
      
      
      
      
      
        
        
        
        
          
          
        
        <a href="/projects/nop-entropy/docs/tutorial/tutorial/">入门教程</a>
      
      
        <ul>
  
  
    
  
  
    <li>
      
      
      
      
      
        
        
        
        
          
          
        
        <a href="/projects/nop-entropy/docs/tutorial/simple/1-simple-service/">1. 极简服务层开发</a>
      
      
    </li>
  
    <li>
      
      
      
      
      
        
        
        
        
          
          
        
        <a href="/projects/nop-entropy/docs/tutorial/simple/2-simple-dao/">2. 极简数据访问层开发</a>
      
      
    </li>
  
    <li>
      
      
      
      
      
        
        
        
        
          
          
        
        <a href="/projects/nop-entropy/docs/tutorial/simple/4-complex-query/">4. 复杂查询</a>
      
      
    </li>
  
    <li>
      
      
      
      
      
        
        
        
        
          
          
        
        <a href="/projects/nop-entropy/docs/tutorial/simple/5-dynamic-sql/">5. 动态SQL管理</a>
      
      
    </li>
  
</ul>

      
    </li>
  
    <li>
      
      
      
      
      
        
        
        
        
          
          
        
        <a href="/projects/nop-entropy/docs/compare/">与其他平台的对比</a>
      
      
    </li>
  
</ul>

      
    </li>
  
    <li>
      
      
      
      
      
        
        
        
        
          
          
        
        <a href="/projects/nop-entropy/docs/user-guide/">用户指南</a>
      
      
        <ul>
  
  
    
  
  
    <li>
      
      
      
      
      
        
        
        
        
          
          
        
        <a href="/projects/nop-entropy/docs/user-guide/installation/">安装和配置</a>
      
      
    </li>
  
    <li>
      
      
      
      
      
        
        
        
        
          
          
        
        <a href="/projects/nop-entropy/docs/user-guide/report/">报表引擎</a>
      
      
    </li>
  
    <li>
      
      
      
      
      
        
        
        
        
          
          
        
        <a href="/projects/nop-entropy/docs/user-guide/idea/idea-plugin/">IDEA插件使用</a>
      
      
    </li>
  
    <li>
      
      
      
      
      
        
        
        
        
          
          
        
        <a href="/projects/nop-entropy/docs/user-guide/monitor/grafana/">监控</a>
      
      
    </li>
  
</ul>

      
    </li>
  
    <li>
      
      
      
      
      
        
        
        
        
          
          
        
        <a href="/projects/nop-entropy/docs/arch/">软件架构</a>
      
      
        <ul>
  
  
    
  
  
    <li>
      
      
      
      
      
        
        
        
        
          
          
        
        <a href="/projects/nop-entropy/docs/arch/module-dependency/">模块依赖关系</a>
      
      
    </li>
  
    <li>
      
      
      
      
      
        
        
        
        
          
          
        
        <a href="/projects/nop-entropy/docs/core-code-guidance/">核心代码阅读导引</a>
      
      
    </li>
  
</ul>

      
    </li>
  
    <li>
      
      
      
      
      
        
        
        
        
          
          
        
        <a href="/projects/nop-entropy/docs/theory/">理论基础</a>
      
      
    </li>
  
    <li>
      
      
      
      
      
        
        
        
        
          
          
        
        <a href="/projects/nop-entropy/docs/dev-guide/">开发指南</a>
      
      
        <ul>
  
  
    
  
  
    <li>
      
      
      
      
      
        
        
        
        
          
          
        
        <a href="/projects/nop-entropy/docs/dev-guide/codegen/">代码生成器</a>
      
      
        <ul>
  
  
    
  
  
    <li>
      
      
      
      
      
        
        
        
        
          
          
        
        <a href="/projects/nop-entropy/docs/dev-guide/cli/">命令行工具</a>
      
      
    </li>
  
    <li>
      
      
      
      
      
        
        
        
        
          
          
        
        <a href="/projects/nop-entropy/docs/dev-guide/command/command/">命令行开发支持</a>
      
      
    </li>
  
</ul>

      
    </li>
  
    <li>
      
      
      
      
      
        
        
        
        
          
          
        
        <a href="/projects/nop-entropy/docs/dev-guide/config/">配置管理</a>
      
      
    </li>
  
    <li>
      
      
      
      
      
        
        
        
        
          
          
        
        <a href="/projects/nop-entropy/docs/dev-guide/ioc/">IoC容器</a>
      
      
        <ul>
  
  
    
  
  
    <li>
      
      
      
      
      
        
        
        
        
          
          
        
        <a href="/projects/nop-entropy/docs/dev-guide/ioc/aop/">AOP支持</a>
      
      
    </li>
  
</ul>

      
    </li>
  
    <li>
      
      
      
      
      
        
        
        
        
          
          
        
        <a href="/projects/nop-entropy/docs/dev-guide/orm/">ORM框架</a>
      
      
    </li>
  
    <li>
      
      
      
      
      
        
        
        
        
          
          
        
        <a href="/projects/nop-entropy/docs/dev-guide/xlang/">XLang语言</a>
      
      
        <ul>
  
  
    
  
  
    <li>
      
      
      
      
      
        
        
        
        
          
          
        
        <a href="/projects/nop-entropy/docs/dev-guide/xlang/xdef/">XDef元模型</a>
      
      
    </li>
  
    <li>
      
      
      
      
      
        
        
        
        
          
          
        
        <a href="/projects/nop-entropy/docs/dev-guide/xlang/xdsl/">XDSL领域语言</a>
      
      
    </li>
  
    <li>
      
      
      
      
      
        
        
        
        
          
          
        
        <a href="/projects/nop-entropy/docs/dev-guide/xlang/xscript/">XScript脚本语言</a>
      
      
    </li>
  
    <li>
      
      
      
      
      
        
        
        
        
          
          
        
        <a href="/projects/nop-entropy/docs/dev-guide/xlang/xpl/">Xpl模板语言</a>
      
      
    </li>
  
    <li>
      
      
      
      
      
        
        
        
        
          
          
        
        <a href="/projects/nop-entropy/docs/dev-guide/xlang/meta-programming/">元编程</a>
      
      
    </li>
  
</ul>

      
    </li>
  
    <li>
      
      
      
      
      
        
        
        
        
          
          
        
        <a href="/projects/nop-entropy/docs/dev-guide/model/">Excel模型</a>
      
      
    </li>
  
    <li>
      
      
      
      
      
        
        
        
        
          
          
        
        <a href="/projects/nop-entropy/docs/dev-guide/graphql/">GraphQL引擎</a>
      
      
    </li>
  
    <li>
      
      
      
      
      
        
        
        
        
          
          
        
        <a href="/projects/nop-entropy/docs/dev-guide/microservice/">分布式微服务</a>
      
      
    </li>
  
    <li>
      
      
      
      
      
        
        
        
        
          
          
        
        <a href="/projects/nop-entropy/docs/dev-guide/rule/rule/">规则引擎</a>
      
      
    </li>
  
    <li>
      
      
      
      
      
        
        
        
        
          
          
        
        <a href="/projects/nop-entropy/docs/dev-guide/workflow/task-flow/">逻辑编排</a>
      
      
    </li>
  
    <li>
      
      
      
      
      
        
        
        
        
          
          
        
        <a href="/projects/nop-entropy/docs/dev-guide/autotest/">自动化测试</a>
      
      
    </li>
  
    <li>
      
      
      
      
      
        
        
        
        
          
          
        
        <a href="/projects/nop-entropy/docs/dev-guide/tenant/">多租户</a>
      
      
    </li>
  
    <li>
      
      
      
      
      
        
        
        
        
          
          
        
        <a href="/projects/nop-entropy/docs/dev-guide/delta/delta-customization/">Delta定制</a>
      
      
        <ul>
  
  
    
  
  
    <li>
      
      
      
      
      
        
        
        
        
          
          
        
        <a href="/projects/nop-entropy/docs/dev-guide/vfs/">Delta文件系统</a>
      
      
    </li>
  
</ul>

      
    </li>
  
    <li>
      
      
      
      
      
        
        
        
        
          
          
        
        <a href="/projects/nop-entropy/docs/dev-guide/auth/">权限配置</a>
      
      
    </li>
  
    <li>
      
      
      
      
      
        
        
        
        
          
          
        
        <a href="/projects/nop-entropy/docs/dev-guide/biz/">业务规则</a>
      
      
    </li>
  
    <li>
      
      
      
      
      
        
        
        
        
          
          
        
        <a href="/projects/nop-entropy/docs/dev-guide/nocode/">动态模型</a>
      
      
    </li>
  
    <li>
      
      
      
      
      
        
        
        
        
          
          
        
        <a href="/projects/nop-entropy/docs/dev-guide/xui/">前端模型</a>
      
      
    </li>
  
</ul>

      
    </li>
  
    <li>
      
      
      
      
      
        
        
        
        
          
          
        
        <a href="/projects/nop-entropy/docs/dev-guide/integration/">第三方集成</a>
      
      
        <ul>
  
  
    
  
  
    <li>
      
      
      
      
      
        
        
        
        
          
          
        
        <a href="/projects/nop-entropy/docs/dev-guide/spring/">spring集成</a>
      
      
    </li>
  
    <li>
      
      
      
      
      
        
        
        
        
          
          
        
        <a href="/projects/nop-entropy/docs/dev-guide/quarkus/">quarkus集成</a>
      
      
    </li>
  
</ul>

      
    </li>
  
    <li>
      
      
      
      
      
        
        
        
        
          
          
        
        <a href="/projects/nop-entropy/docs/dev-guide/ide/idea/">IDEA插件</a>
      
      
        <ul>
  
  
    
  
  
    <li>
      
      
      
      
      
        
        
        
        
          
          
        
        <a href="/projects/nop-entropy/docs/dev-guide/ide/plugin-dev/">插件开发</a>
      
      
    </li>
  
</ul>

      
    </li>
  
    <li>
      
      
      
      
      
        
        
        
        
          
          
        
        <a href="/projects/nop-entropy/docs/faq/faq/">常见问题</a>
      
      
        <ul>
  
  
    
  
  
    <li>
      
      
      
      
      
        
        
        
        
          
          
        
        <a href="/projects/nop-entropy/docs/faq/debug-errors/">错误诊断</a>
      
      
    </li>
  
    <li>
      
      
      
      
      
        
        
        
        
          
          
        
        <a href="/projects/nop-entropy/docs/dev-guide/recipe/">常见问题解决方案</a>
      
      
    </li>
  
</ul>

      
    </li>
  
</ul>
</nav>
    </aside>
  
  <main class="Page-main">
    <article class="Article container-fluid">
      <header class="Article-header">
        
  
    <h1 class="Article-title">为什么说XLang是一门创新的程序语言？</h1>
  
  


      </header>
      <div class="Article-content col-md-9"><blockquote>
<p>我们的物理世界是一个四维时空，量子场论和相对论是它底层的构造规则。超弦理论试图突破底层结构空间的限制，在11维时空中建立统一的构造规则。</p>
</blockquote>
<h2 id="一-为什么需要设计XLang语言"><a href="#一-为什么需要设计XLang语言" class="headerlink" title="一. 为什么需要设计XLang语言"></a>一. 为什么需要设计XLang语言</h2><p><img src="https://gitee.com/canonical-entropy/nop-entropy/raw/master/docs/tutorial/simple/images/xlang.png"></p>
<p>XLang语言是Nop平台底层的关键性支撑技术，在形式上它包含了XDef、Xpl、XScript等多个子语言。因为XLang与其他单一语法形式的程序语言有着较大的差异，所以很多人第一次接触时可能会有疑惑，它到底算不算是一种程序语言？它是不是只是在多种现有语言的基础上增加了一些零散的扩展？</p>
<p>这里我想提出一个对程序语言的本质的理解：<strong>一门程序语言定义了一种程序结构空间，程序语言是程序结构空间的构造规则</strong>。也就是说，一门程序语言所能够创造的所有结构以及这些结构之间的所有可行演化路径构成了一个特定的程序结构空间，所有可行的计算都在这个结构空间中发生。</p>
<p>基于以上理解，<strong>XLang语言之所以是一门创新的程序语言，是因为它创造了一个新的程序结构空间，在这个结构空间中可以很方便的实现可逆计算理论所提出的<code>Y = F(X) + Delta</code>的计算范式</strong>。虽然XLang可以认为是包含XDef, XPL, XScript等多个子语言，但是它们作为一个整体才是实现可逆计算的关键所在。<strong>XLang是世界上第一个在语言中明确定义领域结构坐标并内置通用的差量计算规则的程序语言</strong>。</p>
<p><strong>目前大部分人对于软件结构构造的基本理解都是基于还原论的，总是不断向下分解，寻找原子化的成分，然后使用原子进行组装</strong>。原本虚拟化的组件概念在潜意识中实际上是被看作是真实存在的离散个体，类似于物质世界中的粒子，通过嵌套组合来构造世界。但是物理世界中存在着另一种构造方式，那就是波。波是连续存在的模式，通过干涉叠加来构造世界。<strong>XLang语言的特异性就在于它通过差量运算支持连续的叠加构造</strong>。</p>
<h3 id="从结构的观点看程序语言"><a href="#从结构的观点看程序语言" class="headerlink" title="从结构的观点看程序语言"></a>从结构的观点看程序语言</h3><p>通用的高级程序语言从FORTRAN开始，经历了几十年的长期发展，目前已经发展到某种瓶颈。新语言所带来的本质上新颖的特性越来越少，各个高级语言都发展到了所谓的多范式编程阶段，它们的语法特性逐渐开始融合、趋同，比如大部分语言现在都同时支持面向对象式的结构声明，支持函数式的Lambda表达式，支持元编程所需要的自定义注解，支持异步编程所需的Async相关语法和支持库等。</p>
<p>一个有趣的问题是，是否还存在着通用的可抽象的语法特性，它们具有足够的技术价值以至于需要一个新的程序语言来承载？XLang的创新是指出目前主流的的程序语言虽然表面上语法形式差异很大，但是在语法层面之下的基本结构层面是非常相似的，在基本结构层面的创新仍然大有可为。</p>
<p>程序的结构空间本质上是由数据+函数构成，将相关的数据和函数组织在一起就构成自定义的类型，在一般的程序语言中就对应于类（Class）或者接口（Interface）。从结构的层面看，类结构不过是一个Map，可以通过名称来获取到属性或者方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">type <span class="hljs-title class_">MyClass</span> = &#123;<br>  <span class="hljs-attr">name</span>: string,<br>  <span class="hljs-attr">myMethod</span>: <span class="hljs-function">(<span class="hljs-params">arg1:string</span>) =&gt;</span> number<br>&#125;<br><br>或者<br><br>interface <span class="hljs-title class_">MyClass</span>&#123;<br>  <span class="hljs-attr">name</span>: string,<br>  <span class="hljs-attr">myMethod</span>: <span class="hljs-function">(<span class="hljs-params">arg1:string</span>) =&gt;</span> number<br>&#125;<br></code></pre></td></tr></table></figure>

<p>当我们想利用一个已有的自定义类型来得到一个新的类型的时候，可以使用继承或者Traits机制。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">type <span class="hljs-title class_">MySubClass</span> = <span class="hljs-title class_">MyClass</span> &amp; &#123;<br>  <span class="hljs-attr">subName</span>: string<br>&#125;<br><br>或者<br><br>interface <span class="hljs-title class_">MySubClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">MyClass</span> &#123;<br>   <span class="hljs-attr">subName</span>: string<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在概念层面上大概相当于如下构造方式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Map</span> = <span class="hljs-title class_">Map</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Map</span><br></code></pre></td></tr></table></figure>

<p>类继承在结构层面上相当于是将两个Map按照名称叠加覆盖在一起，上一层中的元素会覆盖下一层的元素。</p>
<p>传统的面向对象语言中可以利用继承机制来复用基类。比如说，构造MapX和MapY的时候复用基类Map1，也就是可以复用继承树的下层。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">MapX</span> = <span class="hljs-title class_">Map2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Map1</span><br><span class="hljs-title class_">MapY</span> = <span class="hljs-title class_">Map3</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Map1</span><br></code></pre></td></tr></table></figure>

<p>将继承表达为上述结构构造公式之后，很多问题会变得非常自然直观。比如说，我们能不能交换Map1和Map2的相对位置？也就是说，在构造MapX和MapY的时候，我们仍然是复用Map1，但是并不作为基类，而是选择不同的基类，但是用同样的Map1去覆盖。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">MapX</span> = <span class="hljs-title class_">Map1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Map2</span><br><span class="hljs-title class_">MapY</span> = <span class="hljs-title class_">Map1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Map3</span><br></code></pre></td></tr></table></figure>

<p>有趣的是，很多面向对象程序语言并不支持上述操作，<strong>面向对象并不直接支持复用继承树的上层！</strong></p>
<p>更进一步的思考会发现传统的面向对象在结构层面难以回答的问题还有很多，比如说继承链条中如果存在多个同样的对象会导致什么问题？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">MapX</span> = <span class="hljs-title class_">Map1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Map2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Map1</span><br></code></pre></td></tr></table></figure>

<p><code>C++</code>中多重继承存在概念层面的严重困难，本质原因就是从不同的继承路径复用了同样的Map1之后产生的结构融合障碍。</p>
<p>现代程序语言是通过Traits机制解决了这些问题。比如在Scala语言中，</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Map1</span> </span>&#123;<br>  <span class="hljs-keyword">val</span> name: <span class="hljs-type">String</span> = <span class="hljs-string">&quot;Map1&quot;</span> <span class="hljs-comment">// 同名属性</span><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">method1</span></span>(): <span class="hljs-type">Unit</span> = &#123;<br>    println(<span class="hljs-string">s&quot;Method 1 from <span class="hljs-subst">$name</span>&quot;</span>)<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Map2</span> </span>&#123;<br>  <span class="hljs-keyword">val</span> name: <span class="hljs-type">String</span> = <span class="hljs-string">&quot;Map2&quot;</span> <span class="hljs-comment">// 同名属性</span><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">method2</span></span>(): <span class="hljs-type">Unit</span> = &#123;<br>    println(<span class="hljs-string">s&quot;Method 2 from <span class="hljs-subst">$name</span>&quot;</span>)<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MapX</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Map1</span> <span class="hljs-keyword">with</span> <span class="hljs-title">Map2</span> </span>&#123;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MapY</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Map1</span> <span class="hljs-keyword">with</span> <span class="hljs-title">Map3</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>Scala语言中多个Trait可以定义同名的属性，编译器会自动合并这些属性定义，最终在运行时只会存在一个变量，但是在Java或者C++中，不同类中定义的多个同名属性并不会自动合并为一个。</p>
</blockquote>
<p>传统的面向对象程序语言中 <code>A extends B</code>表示派生类A可以比基类B多，但是具体多了什么并没有一个明确的技术形式把它隔离出来，我们也就无法直接复用这个多出来的部分（Delta差量）。<br>但是Traits机制相比于继承概念来说，它构成一个更加完善的差量语义。**<code>type MapX = Map1 with Map2 with Map1</code>是合法的Scala类型定义！**</p>
<p>对于多重继承所造成的问题，Scala的解决方案是引入所谓的线性化规则，按照一定的顺序将继承链条中的所有类和Trait排成一个线性序列，然后约定上层的元素覆盖下层的元素。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">MapX -&gt; Map2 -&gt; Map1<br></code></pre></td></tr></table></figure>

<h3 id="泛型作为Generator"><a href="#泛型作为Generator" class="headerlink" title="泛型作为Generator"></a>泛型作为Generator</h3><p>泛型(Generic Type)在Java语言中仅仅是用于类型检查，编译器并没有根据泛型参数来执行什么特殊动作。但是在<code>C++</code>语言中，情况则大为不同。<code>C++</code>的泛型编程是通过模板（Templates）实现的，编译器会根据模板参数的不同将同一个模板类实例化为针对特定类型的不同代码。</p>
<p>在 1994 年的 C++ 标准委员会会议 上，Erwin Unruh 进行了一次技惊四座的演示。他编写了一段模板元程序，能够在编译期计算一个数是否是质数，如果是质数，编译器会在错误信息中输出这个质数。这段代码被称为 “Unruh 质数计算”，成为了 C++ 模板元编程的经典示例。<br>Unruh 的演示证明了 C++ 模板在编译期是图灵完备的，这意味着理论上可以在编译期执行任何计算。这一发现开启了 产生式编程（Generative Programming） 的新时代，即利用编译期的计算能力生成代码或优化程序。<br>C++ 的模板元编程（Template Metaprogramming）成为了实现产生式编程的重要工具。通过模板，开发者可以在编译期完成复杂的计算、类型推导和代码生成，从而在运行时获得更高的性能和灵活性。</p>
<p>参见<a target="_blank" rel="noopener" href="https://accu.org/journals/overload/32/183/wu/">C++ Compile-Time Programming</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> i&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">is_prime</span> &#123;<br>  <span class="hljs-keyword">enum</span> &#123;<br>    prim = (p==<span class="hljs-number">2</span>) ||<br>           (p%i) &amp;&amp; is_prime&lt;(i&gt;<span class="hljs-number">2</span>?p:<span class="hljs-number">0</span>),<br>                             i<span class="hljs-number">-1</span>&gt; :: prim &#125;;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">is_prime</span>&lt;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&gt; &#123; <span class="hljs-keyword">enum</span> &#123;prim=<span class="hljs-number">1</span>&#125;; &#125;;<br><br><span class="hljs-keyword">template</span>&lt;&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">is_prime</span>&lt;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&gt; &#123; <span class="hljs-keyword">enum</span> &#123;prim=<span class="hljs-number">1</span>&#125;; &#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-type">int</span> i&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">D</span> &#123; <span class="hljs-built_in">D</span>(<span class="hljs-type">void</span>*); &#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-type">int</span> i&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Prime_print</span> &#123;<br>  Prime_print&lt;i<span class="hljs-number">-1</span>&gt; a;<br>  <span class="hljs-keyword">enum</span> &#123; prim = is_prime&lt;i, i<span class="hljs-number">-1</span>&gt;::prim &#125;;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123; D&lt;i&gt; d = prim ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>; a.<span class="hljs-built_in">f</span>();&#125;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Prime_print</span>&lt;<span class="hljs-number">1</span>&gt; &#123;<br>  <span class="hljs-keyword">enum</span> &#123;prim=<span class="hljs-number">0</span>&#125;;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123; D&lt;<span class="hljs-number">1</span>&gt; d = prim ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>; &#125;;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  Prime_print&lt;<span class="hljs-number">18</span>&gt; a;<br>  a.<span class="hljs-built_in">f</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">unruh.cpp:20:19: error: no viable conversion from ‘int’ to ‘D&lt;17&gt;’<br>…<br>unruh.cpp:20:19: error: no viable conversion from ‘int’ to ‘D&lt;13&gt;’<br>…<br>unruh.cpp:20:19: error: no viable conversion from ‘int’ to ‘D&lt;11&gt;’<br>…<br>unruh.cpp:20:19: error: no viable conversion from ‘int’ to ‘D&lt;7&gt;’<br>…<br>unruh.cpp:20:19: error: no viable conversion from ‘int’ to ‘D&lt;5&gt;’<br>…<br>unruh.cpp:20:19: error: no viable conversion from ‘int’ to ‘D&lt;3&gt;’<br>…<br>unruh.cpp:20:19: error: no viable conversion from ‘int’ to ‘D&lt;2&gt;’<br></code></pre></td></tr></table></figure>

<p>如果从结构层面去理解模板元编程，则它可以被理解为如下构造公式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Map = Generator&lt;Map&gt; = Map&lt;Map&gt;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>A&lt;X,Y&gt; 可以被理解为 A<B>, struct B{ using T1&#x3D;X; using T2&#x3D;Y;}<br>注意，这里的Map指的是编译器在编译期所看到的结构。每一个成员变量，无论它是属性、方法、还是类型声明，在编译器看来，都是Map中的一个条目。<br>即使编译器将参数列表作为List来管理，它也可以看作是一个用下标来作为Key的Map。而且有趣的是，如果是用数组来做管理，则一般无法引入类似继承这种更高级的合成机制。在概念层面上我们一般会选择按名称合并，而不会选择按下标合并。</p>
</blockquote>
<p>作为生成器的模板类在结构层面（编译器所看到的结构）也可以被看作是一个Map。再结合上一节中差量化Traits概念的内容，面向对象程序语言的最强形态在结构层面可以表达为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Map = Map extends Map&lt;Map&gt;<br></code></pre></td></tr></table></figure>

<h3 id="从Map结构到Tree结构"><a href="#从Map结构到Tree结构" class="headerlink" title="从Map结构到Tree结构"></a>从Map结构到Tree结构</h3><p>在编译器看来，所谓的类、模板类、模板参数都可以被看作是Map，而且实际情况也一般是按照Map结构来管理的。至于孤立的函数定义和变量定义，实际上也会属于某种Map，比如模块对象可以看作是一个Map，它包含一组模块内定义的变量、函数和类型等。即使不从属于任何模块，那些独立的函数也会属于某个隐式存在的全局命名空间。</p>
<blockquote>
<p>Lisp语言的内在结构是List，本质上是利用下标来管理元素（原始的Lisp甚至没有下标，只有car、cdr这种逐个遍历的处理机制），但是现在流行的Lisp变种早就引入了类似Map的Associated List结构，使用名称来定位子元素，而不是按照下标去定位。在概念层面上（不考虑冯诺依曼机器按照下标取值的性能优势），List可以看作是用下标来做key的一种特殊的Map。</p>
</blockquote>
<p>现有主流程序语言提供的各种语法可以看作是在以Map为基础的结构空间中不断构造新的Map的各种规则。XLang语言的创新点在于它选择将Map结构扩展为Tree结构，在Tree结构的基础上重新思考软件结构的构造问题。也就是将软件结构的构造公式推广为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Tree = Tree x-extends Tree&lt;Tree&gt;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>Map扩展为Tree，则Map结构之间的extends运算也需要被扩展为Tree结构上的x-extends运算。</p>
</blockquote>
<p>显然Map是Tree的一个特例，Tree结构的每一个节点都可以看作是一个Map， <code>Tree = Map + Nested</code>，因此上面的公式确实可以被看作是对<code>Map extends Map&lt;Map&gt;</code>构造模式的一种推广。<br>但是从另外一个角度去考虑，Tree结构可以通过嵌套组合多个Map构造出来，Map是一种更基本的、更细粒度的结构，那么有必要强调Tree结构吗？所有Tree结构上的运算最终不都能分解为每一级的Map结构上的运算吗？</p>
<p>XLang对这个问题的回答是：在更复杂的Tree结构上建立的软件结构空间（以及这个结构空间中的构造规律）并不能简单的划归到以Map为基础的软件结构空间。也就是说，这里出现了<code>整体 &gt; 部分之和</code>的情况，<strong>Tree的构造规律所具有的整体性分解到Map结构的构造规律之后会丢失一些关键性信息</strong>。</p>
<p>要真正的理解XLang语言的创新之处，必须要了解XLang语言设计背后的下一代软件构造理论：可逆计算理论。可逆计算明确提出逆元和差量的概念，指出全量是差量的一个特例(A&#x3D;0+A)，我们需要在（包含逆元的）差量概念的基础上重建所有对软件世界的理解。可逆计算提出了一个通用的图灵完备的软件构造公式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">App = Delta x-extends Generator&lt;DSL&gt;<br></code></pre></td></tr></table></figure>

<p>XLang语言是在程序语言级别实现这一技术战略的具体实现方案。</p>
<p>关于可逆计算理论的介绍，可以参见我的公众号文章：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/CwCQgYqQZxYmlZcfXEWlgA">可逆计算：下一代软件构造理论</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/aT99VX6ecmZXdemBPnBcoQ">写给程序员的可逆计算理论辨析</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/zGfo7pvKjOCa11PYLJHzzA">写给程序员的可逆计算理论辨析补遗</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/D5bDNkMJ9gYrFb0uDj2EzQ">写给程序员的差量概念辨析,以Git和Docker为例</a></li>
</ol>
<p>根据可逆计算理论，Tree结构的特殊性在于它对应于一个全局坐标系统：树结构上的每个节点和属性都对应于一个唯一的xpath。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">/tasks/task[name=&#x27;test&#x27;]/@name<br></code></pre></td></tr></table></figure>

<p>上述的xpath表示tasks节点下的名称为test的子节点的name属性。</p>
<p>首先我们来明确一下坐标系统的作用: 每一个业务上关心的值在坐标系统中都具有唯一的坐标，可以通过这个坐标来实现值的读取和修改。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">value = get(path);<br>set(path,value);<br></code></pre></td></tr></table></figure>

<p>Map结构的问题在于它只提供两级坐标：第一级定位到Map，第二级在Map内定位到属性或者方法。但是这种简单的坐标系统无法实现业务层面上精确的区分。比如说</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dialog</span>&#123;<br>    String title;<br>    List&lt;Button&gt; actions;<br>    List&lt;Component&gt; body;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Dialog对象具有一组操作按钮，如果我们想定位到其中的【提交】按钮，把它的label属性修改为【确定】，在现有的程序语言中是没有一种简便直观的定位手段的。如果我们只想定制在某个场景下使用的Dialog（比如为它增加一个属性），使用一般程序语言配套的AOP机制也无法实现：因为<strong>AOP的定位系统是基于类型的</strong>。而在XLang语言中，可以直接使用如下描述</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dialog</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">actions</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">label</span>=<span class="hljs-string">&quot;确定&quot;</span> /&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">actionss</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dialog</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>目前程序语言的研究一般集中在类型系统，但是研究类型的原因在于不同的对象可以具有相同的类型，从而研究类型比研究原本的对象结构要简单而且不会涉及到对象的生命周期问题。<strong>这导致类型系统并不是一个合格的坐标系：类型相同的对象在类型系统坐标系中无法被区分开来，因而也就无法继续建立精细的差量构造</strong>。</p>
<h2 id="可扩展设计必然需要领域结构坐标系"><a href="#可扩展设计必然需要领域结构坐标系" class="headerlink" title="可扩展设计必然需要领域结构坐标系"></a>可扩展设计必然需要领域结构坐标系</h2><p>在软件开发中，所谓的可扩展性指的是在不需要修改原始代码的情况下，通过添加额外的代码或差异信息，可以满足新的需求或实现新的功能。如果在完全抽象的数学层面去理解软件开发中的扩展机制，我们可以认为它对应于如下公式：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Y = X + Delta<br></code></pre></td></tr></table></figure>

<ul>
<li>X对应于我们已经编写完毕的基础代码，它不会随需求的变化而变化  </li>
<li>Delta对应于额外增加的配置信息或者差异化代码</li>
</ul>
<p>在这个视角下，所谓的可扩展性方面的研究就等价于Delta差量的定义和运算关系方面的研究。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">X = A + B + C<br>Y = (A + dA) + (B + dB) + (C + dC)  // 差量无处不在<br>   = (A + B + C) + (dA + dB + dC)  // 差量可以聚合在一起，独立于基础代码存放<br>   = X + Delta // 差量满足结合律，可以独立于Base实现合并运算<br></code></pre></td></tr></table></figure>

<p>假设X由A、B、C等多个部分构成，需求变更导致的差异性修改是遍布系统各处的，<strong>如果要求所有零碎的修改都可以独立于原系统源码来管理和存放</strong>（差量的独立性），并且小的差量还可以复合为一个更大粒度的差量（差量的可复合性），那么必然需要一个坐标系统用于精确定位。具体来说，<code>dA</code>与<code>A</code>分离之后，存放到独立存在的Delta中，那么它必然保留了某种定位坐标，只有这样，当Delta与<code>X</code>结合的时候，才可以重新找到原始的结构<code>A</code>，然后与<code>A</code>相结合。</p>
<h3 id="Delta与Patch和插件机制的区别"><a href="#Delta与Patch和插件机制的区别" class="headerlink" title="Delta与Patch和插件机制的区别"></a>Delta与Patch和插件机制的区别</h3><p>首先需要指出的是，类似于Git的Patch和分支管理不满足Delta的独立性和可复合性。Patch总是和特定的Base代码版本绑定在一起，在不知道Base的情况下无法将多个Patch合并为一个更大的Patch。详细分析参见文章<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/D5bDNkMJ9gYrFb0uDj2EzQ">写给程序员的差量概念辨析,以Git和Docker为例</a>。</p>
<p>第二个需要强调的地方是，差量与传统编程领域中的扩展点和插件机制有着本质性差异。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">X = A + B + C<br>Y = A + B + D<br>  = X + (-C) + D<br>  = X + Delta<br></code></pre></td></tr></table></figure>

<p>Delta差量不仅仅是向系统中增加内容。如果我们要实现粗粒度的系统级别的复用，所对应的差量必然包含减少的语义（比如，我们需要去除基础产品中定义的一个Bean）。实际上一个粗粒度的差量一定是加和减的混合。</p>
<p>另外需要注意的是，<strong>插件机制只支持少量事先确定的扩展点</strong>，我们并不可能在原始设计之外通过插件来定制原有系统的功能。但是Delta的概念则不同，只要存在一个全局的结构坐标系，这个坐标系中的任何一点上都可以引入Delta差量。</p>
<p>如果TypeScript被认为是JavaScript + JSX + Type扩展，那么XLang可以看作是 JavaScript + XPL + 差量计算 + 元模型+ 元编程扩展。</p>
<p>一般的程序语言很强调语法形式，但是XLang强调的是语法形式不重要，不同展现形式之间可以进行可逆转换，此外语义结构应该支持差量分解、合并。</p>
<ol>
<li>XPL模板语言是一种类似Freemarker的XML格式的模板语言，但是它的AST语法树与XScript是同一个AST语法树，这样这两者的元编程和类型分析等可以统一实现。后续也有打算开发更多的语法前端，比如类似Python的语法形式也可以解析到XLang的AST语法树，这样可以在多种形式之间自由转换。</li>
<li>与JSX不同，XLang提供了一种更加灵活、可扩展性更强的方式实现JavaScript语法中嵌入XML，以及在XML中嵌入JavaScript</li>
<li>XLang在XML语法方面提供了XDef元模型定义语言，支持定义新的DSL语言。这个子语言的作用类似于XML Schema语言，但是更加直观、强大。</li>
<li>使用XDef定义的所有DSL统称为XDSL, 这些XDSL都自动具有<code>x:override</code>， <code>x:extends</code>, <code>x:gen-extends</code>等语法特性。这些语法特性是可逆计算理论所提出的，在此前的程序语言中没有建立这种通用的抽象。<br>也就是说，XLang是第一个内置通用差量计算语法的程序语言。</li>
<li>XLang可以认为是包含XDef, XPL, XScript等多个子语言，但是它们作为一个整体才能实现可逆计算理论所提出的Y &#x3D; F(X) + Delta的计算范式。</li>
<li>XLang与其他语言的本质区别在于，它是基于可逆计算理论、面向DSL开发的程序语言。一般语言都是直接面向应用开发的，我们直接使用这些语言来对业务建模，实现业务逻辑。但是使用XLang，我们先建立一个DSL，<br>然后再使用DSL来描述业务。并且开发一个DSL的成本非常低，最基本的情况下只需要使用XDef语言定义XDef元模型文件，即可得到这个新的DSL的解析器、验证器、IDE插件、可视化编辑器等。</li>
<li>Jetbrains公司有一个产品MPS，它也是支持先开发DSL，然后再用DSL来描述业务。MPS底层是自己定义的一套底层语言机制。Nop平台是一个类似于MPS的低代码开发平台，它的底层就是XLang语言。只不过Nop平台的指导理论是可逆计算，与MPS的技术路线和指导思想有着本质差异。<br>但是技术发展目标是类似的。</li>
</ol>
<p>支持泛型的面向对象程序语言 在结构层面的计算模式可以看作是 Map &#x3D;  Map extends Map<Map>，而可逆计算理论以及XLang语言是将这种计算范式从Map结构扩展到Tree结构，并且引入包含删除语义的x-extends差量合并运算<br>Tree &#x3D; Tree x-extends Tree<Tree></p>
<p>一般的通用程序语言，比如C#和Java，它们试图解决的问题和采用的解决方案本质上是类似的，语法和语义层面基本也是可以一一对应的。XLang与这些语言都不同，它试图基于Tree和Delta差量的概念重建程序结构空间。程序语言是程序结构空间的构造规则，而XLang就是这个新视角下的程序结构空间的构造规则</p>
<p>可逆计算是一个创新性很强的软件构造理论，而XLang是实现可逆计算理论的一个关键手段。如果只是从传统的程序语言角度去理解，面向的是传统的软件结构空间和传统的思想路线，可能无法感知到XLang到底要解决什么问题，为什么此前所有的技术都无法解决这些问题。</p>
<p>创新性的语言所提出的问题和所实现的解决方案都是不同于传统语言的。比如rust它提出了对于内存安全和并发安全的新的认知，并创造了新的语法结构作为解决方案。XLang语言是基于可逆计算理论所提出的新的软件构造的结构规律，提出了一整套针对Tree结构的生成、转换、分解、合并语法规则。其实Lisp就可以看作是最早的使用通用Tree结构的程序语言，但是Lisp并没有建立Tree的差量的概念。根据可逆计算理论， A &#x3D; 0 + A，在存在单位元的情况下，任何全量都是差量的特例，我们应该在差量概念的基础上重建所有理解。</p>
<p>SQL语言是面向表结构的，具有一个内置的Schema定义语言，并且具有存储过程子语法。而XLang是面向Tree结构和DSL开发的，具有内置的XDef元模型语言和类似JavaScript的XScript子语法。</p>
<h2 id="二-XLang的具体语法设计"><a href="#二-XLang的具体语法设计" class="headerlink" title="二. XLang的具体语法设计"></a>二. XLang的具体语法设计</h2><h2 id="三-语言之外的世界"><a href="#三-语言之外的世界" class="headerlink" title="三. 语言之外的世界"></a>三. 语言之外的世界</h2>
</div>
      <footer class="Article-footer col-md-3">
        
          
          
          
          
            
          
          
            <div class="Widget">
              <div class="Widget-body"><a href="https://gitee.com/canonical-entropy/nop-entropy/edit/master/docs/theory/why-xlang-is-innovative.md" target="_blank" rel=" rel="external nofollow"">在 Gitee 上编辑文档内容</a></div>
            </div>
          
        
        
  

  <section class="Widget Widget--toc">
  <div class="Widget-header">
    <h2 class="Widget-title">目录</h2>
  </div>
  <div class="Widget-body"></div>
</section>



      </footer>
    </article>
    <footer class="Page-footer Footer">
  <div class="container-fluid">
    
    <div class="Footer-description">
      
        <!-- Important links -->
        <nav class="Footer-navs">
          <ul><li><a href="/projects/nop-entropy/docs"><span>指南</span></a>
</li><li><a href="/community"><span>社区</span></a>
</li><li><a href="https://github.com/nop-platform?utm_source=https://nop-platform.gitee.io&amp;utm_medium=common-footer" target="_blank" rel="external nofollow"><span>GitHub</span></a>
</li><li><a href="https://gitee.com/nop-platform?utm_source=https://nop-platform.gitee.io&amp;utm_medium=common-footer" target="_blank" rel="external nofollow"><span>Gitee</span></a>
</li></ul>
        </nav>
      
      
        <!-- Copyright -->
        <div class="Footer-copyright">
          <p>

&copy; 2024-2025 <a href="https://nop-platform.gitee.io?utm_source=https://nop-platform.gitee.io&amp;utm_medium=common-footer" target="_blank" rel="external nofollow">Nop 社区</a> 版权所有

</p>
          
          
        </div>
      
    </div>
  </div>
</footer>

  </main>
</div>




    <script>$('.Article-content > table').addClass('table table-bordered')</script>
    
<script src="/javascripts/ksio/vendors/share.min.js"></script>

<script src="/javascripts/ksio/components/page.js"></script>

<script src="/javascripts/ksio/components/toc.js"></script>

<script src="/javascripts/ksio/vendors/jquery.timeago.js"></script>

<script src="/javascripts/ksio/vendors/jquery.timeago.zh-CN.js"></script>

<script src="/javascripts/ksio/initializers/time.js"></script>

<script src="/javascripts/ksio/vendors/jquery.lazyload.js"></script>

<script src="/javascripts/ksio/initializers/lazyload.js"></script>

  </body>
</html>

